using PyPlot
using LightGraphs
using StatsBase

start=now();

C=1
B=4

population=Individual[]
populationsize=15
numberoftimesteps=4000
currtimestep=0
mutationrate=0.001
iterations=50

strategies=["ALLC", "ALLD", "TIT4TAT", "CAUTIOUSTIT", "ALTERNATE", "RANDOM"]
STRATSSIZE=6

pb=1
pn=0.85
pr=0.017
relationships=zeros(Integer,populationsize,populationsize)

mutable struct Individual
    strategy::String
    payoff::Int
    moves
    alwaysC::Bool
    alwaysD::Bool
    function Individual(strat, pay)
        if(strat=="rand")
            new(strategies[ceil(Integer,(rand()*(STRATSSIZE)))],pay,[],false,false)
        else
            new(strat,pay,[],false,false)
        end
    end
end

function computemove(self, opponent, iter)
  if(self.alwaysD==true)
    return "D"
  end
  if(self.alwaysC==true)
    return "C"
  end

  out="C"

  if(self.strategy=="ALLD")
    self.alwaysD=true
    out="D"
  end

  if(self.strategy=="ALLC")
    self.alwaysC=true
  end

  if(self.strategy=="TIT4TAT") #The Tit For Tat strategy starts by cooperating then repeats the opponent's previous move
    if(iter>1)
      out=opponent.moves[iter-1]
    end
  end

  if(self.strategy=="CAUTIOUSTIT")#Same as Tit for Tat, but starts by defecting
    out="D"
    if(iter>1)
      out=opponent.moves[iter-1]
    end
  end

  if(self.strategy=="ALTERNATE")
    if(iter>1)
      if(self.moves[iter-1]=="C")
        out=="D"
      end
    end
  end

  if(self.strategy=="RANDOM")
    if(rand()>0.5)
      out=="D"
    end
  end
  return out
end

function addtopayoff(self::Individual, gamepay::Integer)
  self.payoff+=gamepay
end
function mutate(self::Individual)
  self.strategy=strategies[floor(Integer,(rand()*(STRATSSIZE)+1))]
end
function findfitness(self::Individual)
  return self.payoff
end
function clearmoves(self::Individual)
  if(length(self.moves)==iterations)
    for i=1:iterations
      self.moves[i]="None"
    end
  else
    for i=1:length(self.moves)
      self.moves[i]="None"
    end
    for i=1:(iterations-length(self.moves))
        push!(self.moves,"None")
    end
  end
end

function initsim()
  relationships=zeros(Integer,populationsize,populationsize)
  for i=1:populationsize
    guy=Individual("rand",0)
    clearmoves(guy)
    push!(population, guy)
  end
  for i=1:populationsize,j=i:populationsize
    if(j!=i)
      if(rand()<pr)
        relationships[i,j]=1
        relationships[j,i]=1
      end
    end
  end
end

function generationrun()
  death=ceil(Integer,(rand()*populationsize))
  mother=ceil(Integer,(rand()*populationsize))
  while mother==death
    mother=ceil(Integer,(rand()*populationsize))
  end
  offspring=Individual("rand",0)
  relationships[:, death]=0
  relationships[death, :]=0
  for i=1:populationsize
    relationships[death,i]=0
    if(relationships[mother,i]==1 && i!=death && rand()<pn)
      relationships[death,i]=1
      relationships[i,death]=1
    end
    if(i!=death && relationships[mother,i]==0 && rand()<pr)
      relationships[death,i]=1
      relationships[i,death]=1
    end
    if(i==mother && rand()<pb)
      relationships[death,i]=1
      relationships[i,death]=1
    end
  end
  population[death]=offspring
end

simruns=500
degreedistributiondata=zeros(500, populationsize)
clusteringcoefdata=zeros(500,populationsize+1)

for j=1:simruns
    initsim()
    for i=1:numberoftimesteps
        generationrun()
    end
    degrees=zeros(populationsize) #number of individuals with any degree
    clusco=zeros(populationsize+1) #number of individuals w. any cc

    g=Graph().Adjacency(relationships.tolist(),mode=1)

    deg=g.degree(np.arange(populationsize),mode=3,loops=true)
    localcoefs=g.transitivity_local_undirected(np.arange(populationsize),mode="zero")

    for i=1:populationsize
        degrees[deg[i]]+=1
        clusco[trunc(localcoefs[i]*populationsize)]+=1
    end
    popleft=populationsize
    for i in eachindex(degreedistributiondata[0])
        popleft-=degrees[i]
        degrees[i]=popleft/populationsize
    end
    popleft=populationsize
    for i in eachindex(clusteringcoefdata[0])
        popleft-=clusco[i]
        clusco[i]=popleft/populationsize
    end
    degreedistributiondata[j]=degrees
    clusteringcoefdata[j]=clusco
end

xaxisdd=arange(0,length(degreedistributiondata[0]),1)
xaxiscc=arange(0,1,1/(populationsize+1))

fig,ax=subplots(nrows=2,squeeze=false)
avgdegdist=mean(degreedistributiondata,axis=0)
meddegdist=median(degreedistributiondata,axis=0)
ddhigh475=percentile(degreedistributiondata,97.5,axis=0)
ddlow475=percentile(degreedistributiondata,2.5,axis=0)

avgcc=mean(clusteringcoefdata,axis=0)
cchigh475=percentile(clusteringcoefdata,97.5,axis=0)
cclow475=percentile(clusteringcoefdata,2.5,axis=0)

ax[0,0].set_xlim([0,32])
ax[0,0].plot(xaxisdd,avgdegdist,color='black')
ax[0,0].plot(xaxisdd,meddegdist,color="green")
ax[0,0].fill_between(x=xaxisdd,y1=avgdegdist,y2=ddhigh475,color='blue')
ax[0,0].fill_between(x=xaxisdd,y1=avgdegdist,y2=ddlow475,color='blue')

ax[1,0].set_ylim([0,1])
ax[1,0].plot(xaxiscc,avgcc,color='red')
ax[1,0].fill_between(x=xaxiscc,y1=avgcc,y2=cchigh475,color='#FF6666')
ax[1,0].fill_between(x=xaxiscc,y1=avgcc,y2=cclow475,color='#FF6666')

println(now()-start)

show()
